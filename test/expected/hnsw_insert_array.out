CREATE EXTENSION IF NOT EXISTS lanterndb;
CREATE EXTENSION
CREATE TABLE small_world (
    id varchar(3),
    vector real[]
);
CREATE TABLE
INSERT INTO small_world (id, vector) VALUES 
('000', '{0,0,0}'),
('001', '{0,0,1}'),
('010', '{0,1,0}'),
('011', '{0,1,1}'),
('100', '{1,0,0}'),
('101', '{1,0,1}'),
('110', '{1,1,0}'),
('111', '{1,1,1}');
INSERT 0 8
CREATE TABLE IF NOT EXISTS sift_base1k (
    id SERIAL PRIMARY KEY,
    v real[]);
CREATE TABLE
COPY sift_base1k (v) FROM '/tmp/lanterndb/vector_datasets/sift_base1k_arrays.csv' with csv;
COPY 1000
CREATE INDEX ON small_world USING hnsw (vector);
psql:test/sql/hnsw_insert_array.sql:6: INFO:  done init usearch index
psql:test/sql/hnsw_insert_array.sql:6: INFO:  inserted 8 elements
psql:test/sql/hnsw_insert_array.sql:6: INFO:  done saving 8 vectors
CREATE INDEX
CREATE INDEX ON sift_base1k USING hnsw (v) WITH (dims=128);
psql:test/sql/hnsw_insert_array.sql:7: INFO:  done init usearch index
psql:test/sql/hnsw_insert_array.sql:7: INFO:  inserted 1000 elements
psql:test/sql/hnsw_insert_array.sql:7: INFO:  done saving 1000 vectors
CREATE INDEX
SET enable_seqscan = off;
SET
INSERT INTO small_world (id, vector) VALUES ('xxx', '{0,0,0}');
INSERT 0 1
INSERT INTO small_world (id, vector) VALUES ('x11', '{0,0,110}');
INSERT 0 1
INSERT INTO small_world (id, vector) VALUES 
('000', '{0,0,0}'),
('001', '{0,0,1}'),
('010', '{0,1,0}'),
('011', '{0,1,1}'),
('100', '{1,0,0}'),
('101', '{1,0,1}'),
('110', '{1,1,0}'),
('111', '{1,1,1}');
INSERT 0 8
SELECT * FROM (
    SELECT id, ROUND( (vector <-> array[0,1,0])::numeric, 2) as dist
    FROM small_world
    ORDER BY vector <-> array[0,1,0] LIMIT 7
) v ORDER BY v.dist, v.id;
psql:test/sql/hnsw_insert_array.sql:27: INFO:  cost estimate
psql:test/sql/hnsw_insert_array.sql:27: INFO:  returning small cost to always use the index
psql:test/sql/hnsw_insert_array.sql:27: INFO:  began scanning with 0 keys and 1 orderbys
psql:test/sql/hnsw_insert_array.sql:27: INFO:  starting scan with dimensions=3 M=16 efConstruction=128 ef=64
psql:test/sql/hnsw_insert_array.sql:27: INFO:  usearch index initialized
 id  | dist 
-----+------
 010 | 0.00
 011 | 1.00
 110 | 1.00
 001 | 2.00
 100 | 2.00
 111 | 2.00
 101 | 3.00
(7 rows)

INSERT INTO small_world (id, vector) VALUES 
('000', '{0,0,0}'),
('001', '{0,0,1}'),
('010', '{0,1,0}'),
('011', '{0,1,1}'),
('100', '{1,0,0}'),
('101', '{1,0,1}'),
('110', '{1,1,0}'),
('111', '{1,1,1}');
INSERT 0 8
SELECT * FROM (
    SELECT id, ROUND( (vector <-> array[0,1,0])::numeric, 2) as dist
    FROM small_world
    ORDER BY vector <-> array[0,1,0] LIMIT 7
) v ORDER BY v.dist, v.id;
psql:test/sql/hnsw_insert_array.sql:43: INFO:  cost estimate
psql:test/sql/hnsw_insert_array.sql:43: INFO:  returning small cost to always use the index
psql:test/sql/hnsw_insert_array.sql:43: INFO:  began scanning with 0 keys and 1 orderbys
psql:test/sql/hnsw_insert_array.sql:43: INFO:  starting scan with dimensions=3 M=16 efConstruction=128 ef=64
psql:test/sql/hnsw_insert_array.sql:43: INFO:  usearch index initialized
 id  | dist 
-----+------
 010 | 0.00
 011 | 1.00
 110 | 1.00
 001 | 2.00
 100 | 2.00
 111 | 2.00
 101 | 3.00
(7 rows)

SELECT v as v42 FROM sift_base1k WHERE id = 42 
BEGIN;
BEGIN
DROP INDEX IF EXISTS sift_base1k_hnsw_idx;
psql:test/sql/hnsw_insert_array.sql:49: NOTICE:  index "sift_base1k_hnsw_idx" does not exist, skipping
DROP INDEX
EXPLAIN (COSTS FALSE) SELECT id, ROUND((v <-> '{1,0,0,0,0,0,21,35,1,0,0,0,0,77,51,42,66,2,0,0,0,86,140,71,52,1,0,0,0,0,23,70,2,0,0,0,0,64,73,50,11,0,0,0,0,140,97,18,140,64,0,0,0,99,51,65,78,11,0,0,0,0,41,76,0,0,0,0,0,124,82,2,48,1,0,0,0,118,31,5,140,21,0,0,0,4,12,78,12,0,0,0,0,0,58,117,1,0,0,0,2,25,7,2,46,2,0,0,1,12,4,8,140,9,0,0,0,1,8,16,3,0,0,0,0,0,21,34}')::numeric, 2) FROM sift_base1k ORDER BY v <-> '{1,0,0,0,0,0,21,35,1,0,0,0,0,77,51,42,66,2,0,0,0,86,140,71,52,1,0,0,0,0,23,70,2,0,0,0,0,64,73,50,11,0,0,0,0,140,97,18,140,64,0,0,0,99,51,65,78,11,0,0,0,0,41,76,0,0,0,0,0,124,82,2,48,1,0,0,0,118,31,5,140,21,0,0,0,4,12,78,12,0,0,0,0,0,58,117,1,0,0,0,2,25,7,2,46,2,0,0,1,12,4,8,140,9,0,0,0,1,8,16,3,0,0,0,0,0,21,34}' LIMIT 10;
psql:test/sql/hnsw_insert_array.sql:50: INFO:  cost estimate
psql:test/sql/hnsw_insert_array.sql:50: INFO:  returning small cost to always use the index
                                                                                                                                                                          QUERY PLAN                                                                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Index Scan using sift_base1k_v_idx on sift_base1k
         Order By: (v <-> '{1,0,0,0,0,0,21,35,1,0,0,0,0,77,51,42,66,2,0,0,0,86,140,71,52,1,0,0,0,0,23,70,2,0,0,0,0,64,73,50,11,0,0,0,0,140,97,18,140,64,0,0,0,99,51,65,78,11,0,0,0,0,41,76,0,0,0,0,0,124,82,2,48,1,0,0,0,118,31,5,140,21,0,0,0,4,12,78,12,0,0,0,0,0,58,117,1,0,0,0,2,25,7,2,46,2,0,0,1,12,4,8,140,9,0,0,0,1,8,16,3,0,0,0,0,0,21,34}'::real[])
(3 rows)

SELECT id, ROUND((v <-> '{1,0,0,0,0,0,21,35,1,0,0,0,0,77,51,42,66,2,0,0,0,86,140,71,52,1,0,0,0,0,23,70,2,0,0,0,0,64,73,50,11,0,0,0,0,140,97,18,140,64,0,0,0,99,51,65,78,11,0,0,0,0,41,76,0,0,0,0,0,124,82,2,48,1,0,0,0,118,31,5,140,21,0,0,0,4,12,78,12,0,0,0,0,0,58,117,1,0,0,0,2,25,7,2,46,2,0,0,1,12,4,8,140,9,0,0,0,1,8,16,3,0,0,0,0,0,21,34}')::numeric, 2) FROM sift_base1k ORDER BY v <-> '{1,0,0,0,0,0,21,35,1,0,0,0,0,77,51,42,66,2,0,0,0,86,140,71,52,1,0,0,0,0,23,70,2,0,0,0,0,64,73,50,11,0,0,0,0,140,97,18,140,64,0,0,0,99,51,65,78,11,0,0,0,0,41,76,0,0,0,0,0,124,82,2,48,1,0,0,0,118,31,5,140,21,0,0,0,4,12,78,12,0,0,0,0,0,58,117,1,0,0,0,2,25,7,2,46,2,0,0,1,12,4,8,140,9,0,0,0,1,8,16,3,0,0,0,0,0,21,34}' LIMIT 10;
psql:test/sql/hnsw_insert_array.sql:51: INFO:  cost estimate
psql:test/sql/hnsw_insert_array.sql:51: INFO:  returning small cost to always use the index
psql:test/sql/hnsw_insert_array.sql:51: INFO:  began scanning with 0 keys and 1 orderbys
psql:test/sql/hnsw_insert_array.sql:51: INFO:  starting scan with dimensions=128 M=16 efConstruction=128 ef=64
psql:test/sql/hnsw_insert_array.sql:51: INFO:  usearch index initialized
 id  |  round   
-----+----------
  42 |     0.00
  36 | 10530.00
  48 | 51038.00
  39 | 56265.00
 886 | 71637.00
 402 | 77013.00
 340 | 87261.00
 331 | 87796.00
 518 | 85024.00
 682 | 94988.00
(10 rows)

ROLLBACK;
ROLLBACK
EXPLAIN (COSTS FALSE) SELECT id, ROUND((v <-> '{1,0,0,0,0,0,21,35,1,0,0,0,0,77,51,42,66,2,0,0,0,86,140,71,52,1,0,0,0,0,23,70,2,0,0,0,0,64,73,50,11,0,0,0,0,140,97,18,140,64,0,0,0,99,51,65,78,11,0,0,0,0,41,76,0,0,0,0,0,124,82,2,48,1,0,0,0,118,31,5,140,21,0,0,0,4,12,78,12,0,0,0,0,0,58,117,1,0,0,0,2,25,7,2,46,2,0,0,1,12,4,8,140,9,0,0,0,1,8,16,3,0,0,0,0,0,21,34}')::numeric, 2) FROM sift_base1k ORDER BY v <-> '{1,0,0,0,0,0,21,35,1,0,0,0,0,77,51,42,66,2,0,0,0,86,140,71,52,1,0,0,0,0,23,70,2,0,0,0,0,64,73,50,11,0,0,0,0,140,97,18,140,64,0,0,0,99,51,65,78,11,0,0,0,0,41,76,0,0,0,0,0,124,82,2,48,1,0,0,0,118,31,5,140,21,0,0,0,4,12,78,12,0,0,0,0,0,58,117,1,0,0,0,2,25,7,2,46,2,0,0,1,12,4,8,140,9,0,0,0,1,8,16,3,0,0,0,0,0,21,34}' LIMIT 10;
psql:test/sql/hnsw_insert_array.sql:55: INFO:  cost estimate
psql:test/sql/hnsw_insert_array.sql:55: INFO:  returning small cost to always use the index
                                                                                                                                                                          QUERY PLAN                                                                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Index Scan using sift_base1k_v_idx on sift_base1k
         Order By: (v <-> '{1,0,0,0,0,0,21,35,1,0,0,0,0,77,51,42,66,2,0,0,0,86,140,71,52,1,0,0,0,0,23,70,2,0,0,0,0,64,73,50,11,0,0,0,0,140,97,18,140,64,0,0,0,99,51,65,78,11,0,0,0,0,41,76,0,0,0,0,0,124,82,2,48,1,0,0,0,118,31,5,140,21,0,0,0,4,12,78,12,0,0,0,0,0,58,117,1,0,0,0,2,25,7,2,46,2,0,0,1,12,4,8,140,9,0,0,0,1,8,16,3,0,0,0,0,0,21,34}'::real[])
(3 rows)

SELECT id, ROUND((v <-> '{1,0,0,0,0,0,21,35,1,0,0,0,0,77,51,42,66,2,0,0,0,86,140,71,52,1,0,0,0,0,23,70,2,0,0,0,0,64,73,50,11,0,0,0,0,140,97,18,140,64,0,0,0,99,51,65,78,11,0,0,0,0,41,76,0,0,0,0,0,124,82,2,48,1,0,0,0,118,31,5,140,21,0,0,0,4,12,78,12,0,0,0,0,0,58,117,1,0,0,0,2,25,7,2,46,2,0,0,1,12,4,8,140,9,0,0,0,1,8,16,3,0,0,0,0,0,21,34}')::numeric, 2) FROM sift_base1k ORDER BY v <-> '{1,0,0,0,0,0,21,35,1,0,0,0,0,77,51,42,66,2,0,0,0,86,140,71,52,1,0,0,0,0,23,70,2,0,0,0,0,64,73,50,11,0,0,0,0,140,97,18,140,64,0,0,0,99,51,65,78,11,0,0,0,0,41,76,0,0,0,0,0,124,82,2,48,1,0,0,0,118,31,5,140,21,0,0,0,4,12,78,12,0,0,0,0,0,58,117,1,0,0,0,2,25,7,2,46,2,0,0,1,12,4,8,140,9,0,0,0,1,8,16,3,0,0,0,0,0,21,34}' LIMIT 10;
psql:test/sql/hnsw_insert_array.sql:56: INFO:  cost estimate
psql:test/sql/hnsw_insert_array.sql:56: INFO:  returning small cost to always use the index
psql:test/sql/hnsw_insert_array.sql:56: INFO:  began scanning with 0 keys and 1 orderbys
psql:test/sql/hnsw_insert_array.sql:56: INFO:  starting scan with dimensions=128 M=16 efConstruction=128 ef=64
psql:test/sql/hnsw_insert_array.sql:56: INFO:  usearch index initialized
 id  |  round   
-----+----------
  42 |     0.00
  36 | 10530.00
  48 | 51038.00
  39 | 56265.00
 886 | 71637.00
 402 | 77013.00
 340 | 87261.00
 331 | 87796.00
 518 | 85024.00
 682 | 94988.00
(10 rows)

CREATE TABLE new_small_world as SELECT * from small_world;
SELECT 26
CREATE INDEX ON new_small_world USING hnsw (vector);
psql:test/sql/hnsw_insert_array.sql:62: INFO:  done init usearch index
psql:test/sql/hnsw_insert_array.sql:62: INFO:  inserted 26 elements
psql:test/sql/hnsw_insert_array.sql:62: INFO:  done saving 26 vectors
CREATE INDEX
INSERT INTO new_small_world (id, vector) VALUES
('000', '{0,0,0}'),
('001', '{0,0,1}'),
('010', '{0,1,0}'),
('011', '{0,1,1}'),
('100', '{1,0,0}'),
('101', '{1,0,1}'),
('110', '{1,1,0}'),
('111', '{1,1,1}');
INSERT 0 8
SELECT '{0,0,0}'::real[] as v42  
EXPLAIN (COSTS FALSE) SELECT id, ROUND((vector <-> '{0,0,0}')::numeric, 2) FROM new_small_world ORDER BY vector <-> '{0,0,0}' LIMIT 10;
psql:test/sql/hnsw_insert_array.sql:75: INFO:  cost estimate
psql:test/sql/hnsw_insert_array.sql:75: INFO:  returning small cost to always use the index
                              QUERY PLAN                              
----------------------------------------------------------------------
 Limit
   ->  Index Scan using new_small_world_vector_idx on new_small_world
         Order By: (vector <-> '{0,0,0}'::real[])
(3 rows)

SELECT id, ROUND((vector <-> '{0,0,0}')::numeric, 2) FROM new_small_world ORDER BY vector <-> '{0,0,0}' LIMIT 10;
psql:test/sql/hnsw_insert_array.sql:76: INFO:  cost estimate
psql:test/sql/hnsw_insert_array.sql:76: INFO:  returning small cost to always use the index
psql:test/sql/hnsw_insert_array.sql:76: INFO:  began scanning with 0 keys and 1 orderbys
psql:test/sql/hnsw_insert_array.sql:76: INFO:  starting scan with dimensions=3 M=16 efConstruction=128 ef=64
psql:test/sql/hnsw_insert_array.sql:76: INFO:  usearch index initialized
 id  | round 
-----+-------
 111 |  3.00
 110 |  2.00
 101 |  2.00
 100 |  1.00
 011 |  2.00
 010 |  1.00
 001 |  1.00
 000 |  0.00
 111 |  3.00
 110 |  2.00
(10 rows)

SELECT count(*) from sift_base1k;
psql:test/sql/hnsw_insert_array.sql:78: INFO:  cost estimate
 count 
-------
  1000
(1 row)

SELECT * from ldb_get_indexes('sift_base1k');
     indexname     |  size  |                                       indexdef                                        
-------------------+--------+---------------------------------------------------------------------------------------
 sift_base1k_pkey  | 40 kB  | CREATE UNIQUE INDEX sift_base1k_pkey ON public.sift_base1k USING btree (id)
 sift_base1k_v_idx | 872 kB | CREATE INDEX sift_base1k_v_idx ON public.sift_base1k USING hnsw (v) WITH (dims='128')
(2 rows)

INSERT INTO sift_base1k(v)
SELECT v FROM sift_base1k WHERE id <= 444 AND v IS NOT NULL;
INSERT 0 444
SELECT count(*) from sift_base1k;
psql:test/sql/hnsw_insert_array.sql:82: INFO:  cost estimate
 count 
-------
  1444
(1 row)

SELECT * from ldb_get_indexes('sift_base1k');
     indexname     |  size   |                                       indexdef                                        
-------------------+---------+---------------------------------------------------------------------------------------
 sift_base1k_pkey  | 48 kB   | CREATE UNIQUE INDEX sift_base1k_pkey ON public.sift_base1k USING btree (id)
 sift_base1k_v_idx | 1168 kB | CREATE INDEX sift_base1k_v_idx ON public.sift_base1k USING hnsw (v) WITH (dims='128')
(2 rows)

